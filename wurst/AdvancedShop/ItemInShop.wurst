package ItemInShop

import ErrorHandling
import LinkedList
import HashMap
import HashList
import ObjectIdGenerator
import ItemObjEditing
import ShopConfig

constant ITEM_DEFINITIONS = new HashMap<int, ItemDefinition>


function LinkedList<ItemInShop>.sortItemList()
    this.sortWith() (a, b) ->
        return a.getTotalCost() - b.getTotalCost()

public function getIconPath(string icon) returns string
    string s = icon
    if icon.length() < 20 or not icon.startsWith("ReplaceableTextures")
        s = "ReplaceableTextures\\CommandButtons\\" + s
    if not icon.endsWith(".blp")
        s += ".blp"
    return s

public function getItemDefintion(int itemId) returns ItemDefinition
    if not compiletime
        error("getItemDefintion cannot be used at runtime")

    return ITEM_DEFINITIONS.get(itemId)


//compiletime to create an item object + icon texture
public function newItem(string icon) returns int
    let id = ITEM_ID_GEN.next()
    if compiletime
        let fullIcon = getIconPath(icon)
        let iDef = new ItemDefinition(id, 'rde1')
            ..setInterfaceIcon(fullIcon)
            ..setAbilities("")
            ..setActivelyUsed(false)
            ..setCooldownGroup("")
            ..setDescription("")
            ..setDroppedWhenCarrierDies(false)
            ..setUseAutomaticallyWhenAcquired(false)
            ..setPerishable(false)
            ..setNumberofCharges(0)
            ..setIgnoreCooldown(false)
            ..setLumberCost(0)
        ITEM_DEFINITIONS.put(id, iDef)
    return id


public class ItemInShop

    private int itemId
    private int category = -1
    private string icon = ""
    private int totalCost = -1
    private int singleCost = -1
    private bool powerUp = false
    private LinkedList<ItemInShop> requirements
    private int recipeSize = 1
    private int visibleRecipeSize = 1
    private bool buildsIntoStarted = false

    private HashList<ItemInShop> buildsIntoDirectly
    private HashList<ItemInShop> buildsIntoTransitively
    private LinkedList<ItemInShop> buildsIntoCombined
    private static constant allItems = new LinkedList<ItemInShop>

    private string name = ""
    private string description = ""

    private static LinkedList<ItemInShop> array itemsInCategory
    private static ItemInShop array itemsInCategoryArray
    private static int array itemsPerCategory
    private static constant itemToIndex = new HashMap<ItemInShop,int>

    private static constant itemIdToItemInShop = new HashMap<int,ItemInShop>

    static function classInit()
        for i=0 to NUM_CATEGORIES-1
            itemsInCategory[i] = new LinkedList<ItemInShop>()

    /*
        Retrieves the object to this item id. It never returns null.
    */
    static function retrieveItemFromId(int itemId) returns ItemInShop
        if itemIdToItemInShop.has(itemId)
            return itemIdToItemInShop.get(itemId)
        else
            return new ItemInShop(itemId)

    /*
        creates an empty object. The object itself can be initialized later,
        but it can already be used as reference. Calculations depending on other
        items are done after all items have been initialized in finalize().
    */
    construct(int itemId)
        this.itemId = itemId
        itemIdToItemInShop.put(itemId, this)
        this.requirements = new LinkedList<ItemInShop>
        this.buildsIntoDirectly = new HashList<ItemInShop>
        this.buildsIntoTransitively = new HashList<ItemInShop>
        this.buildsIntoCombined = new LinkedList<ItemInShop>
        allItems.add(this)

    function setupItem(int category, int totalCost)
        this.category = category
        this.totalCost = totalCost
        this.singleCost = -1
        itemsInCategory[this.category].add(this)

        let itm = createItem(itemId, vec2(0,0))
        this.icon = itm.getIconPath()
        this.name = itm.getName()
        this.description = itm.getExtendedTooltip()
        itm.remove()

    function addRequirement(ItemInShop requirement)
        this.requirements.add(requirement)

    function makePowerUp()
        this.powerUp = true

    function getItemId() returns int
        return this.itemId

    function getIcon() returns string
        return this.icon
        
    function getTotalCost() returns int
        return this.totalCost

    function getSingleCost() returns int
        return this.singleCost

    function getRequirements() returns LinkedList<ItemInShop>
        return this.requirements

    function getRecipeSize() returns int
        return this.recipeSize

    function getVisibleRecipeSize() returns int
        return this.visibleRecipeSize

    function getBuildsInto() returns LinkedList<ItemInShop>
        return this.buildsIntoCombined

    function getName() returns string
        return this.name

    function getDescription() returns string
        return this.description

    function isPowerUp() returns bool
        return this.powerUp

    function calculateGoldCost()
        int childrenCost = 0
        for ItemInShop child in this.requirements
            childrenCost += child.totalCost

        this.singleCost = this.totalCost - childrenCost


    /** After all items have been created the buildsInto lists are built.**/
    static function finalize()
        for ItemInShop itm in allItems
            itm.calculateGoldCost()

        for ItemInShop itm in allItems
            itm.calculateBuildsInto()
            /*for ItemInShop child in itm.requirements
                addBuildsInto(child, itm, 0)*/

        for ItemInShop itm in allItems
            let sortingList = new LinkedList<ItemInShop>()
            for ItemInShop b in itm.buildsIntoDirectly
                sortingList.add(b)
               
            sortingList.sortItemList()
            for ItemInShop b in sortingList
                itm.buildsIntoCombined.add(b)

            sortingList.clear()
            for ItemInShop b in itm.buildsIntoTransitively
                sortingList.add(b)

            sortingList.sortItemList()
            for ItemInShop b in sortingList
                itm.buildsIntoCombined.add(b)

            destroy sortingList


        for i = 0 to NUM_CATEGORIES-1
            itemsInCategory[i].sortItemList()

        for i = 0 to NUM_CATEGORIES-1
            itemsPerCategory[i] = itemsInCategory[i].size()
            int j = 0
            for ItemInShop itm in itemsInCategory[i]
                itemsInCategoryArray[i * MAX_ITEMS_IN_LIST + j] = itm
                itemToIndex.put(itm, i * MAX_ITEMS_IN_LIST + j)
                j++

    private function calculateBuildsInto()
        if buildsIntoStarted
            return
        buildsIntoStarted = true
        for child in requirements
            if not child.buildsIntoDirectly.has(this)
                child.buildsIntoDirectly.add(this)
            recipeSize++
            visibleRecipeSize++
            child.addBuildsIntoTransitively(this, 1)
            
    private function addBuildsIntoTransitively(ItemInShop into, int depth)
        for child in requirements
            if not child.buildsIntoTransitively.has(into)
                child.buildsIntoTransitively.add(into)
            into.recipeSize++
            if depth == 1
                into.visibleRecipeSize++
            child.addBuildsIntoTransitively(into, depth + 1)

    static function getArrayIndex(ItemInShop itm) returns int
        return itemToIndex.get(itm)

    static function getIndex(ItemInShop itm) returns int
        return itemToIndex.get(itm) mod MAX_ITEMS_IN_LIST

    static function getCategory(ItemInShop itm) returns int
        return itemToIndex.get(itm) div MAX_ITEMS_IN_LIST

    static function getItemFromList(int category, int index) returns ItemInShop
        if index < getItemCount(category)
            return itemsInCategoryArray[category * MAX_ITEMS_IN_LIST + index]
        else
            return null

    static function getItemCount(int category) returns int
        return itemsPerCategory[category]

    static function getItemList(int category) returns LinkedList<ItemInShop>
        return itemsInCategory[category]

    static function getItemFromId(int itemId) returns ItemInShop
        if itemIdToItemInShop.has(itemId)
            return itemIdToItemInShop.get(itemId)
        else
            return null

init
    ItemInShop.classInit()